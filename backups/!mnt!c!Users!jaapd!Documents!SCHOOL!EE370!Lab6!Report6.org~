#+TITLE: EE370 Lab6
#+SUBTITLE: Instructor: Paula Quintana
#+AUTHOR: Jaap de Dood
#+DATE: October 10 2017
#+OPTIONS: toc:nil
#+LaTeX_HEADER: \usepackage[margin=1.01in]{geometry}
* Activity 1
In this activity the similarities between a BJT and MOSFET were observed. To do this, the following circuit was set up:
#+ATTR_LATEX: :width 200px
file:image1.jpg
In this circuit, the fan is switched on and off using a BJT and the following code:
#+BEGIN_EXAMPLE
' -----[ Title ]-----------------------------------------------------------
' Process Control - FanOnOffControl
' Controls 12Vdc fan with transistor driver
' {$STAMP BS2}
' {$PBASIC 2.5}
' -----[ Declarations ]----------------------------------------------------
Fan PIN 2 ' Fan Driver I/O
OnTime CON 5000 ' Time to leave fan on
OffTime CON 5000 ' Time to leave fan off
' -----[ Main Routine ]----------------------------------------------------
DO
 HIGH FAN ' Energize fan
 PAUSE OnTime ' Pause while running
 LOW FAN ' De-energize fan
 PAUSE OffTime ' Pause while off
LOOP
#+END_EXAMPLE
This code simply switches the fan on and off for 5000ms each by alternating a signal to the base of the BJT. Next, the BJT was swapped out for an N-channel MOSFET and the circuit functioned exactly the same. A BJT is a current-controlled device, meaning, the current flowing into the collector will be proportional to the current flowing in the base. As a result, BJTs have a linear region in between cutoff and saturation that is desirable for certain applications such as amplifier and audio applications. A MOSFET however, is voltage controlled and will conduct above a certain gate voltage. This gate voltage can easily be controlled using a microcontroller like the BASIC Stamp.
*** Q: Are MOSFETs better alternatives for digital switches than BJTs? Why?
The main disadvantage of using a BJT as a switch is that the base requires a certain current proportional to the collector current. This means there must be a constant current circuit to the base of the transistor that also constantly draws power while in operation. In high power applications this can be a noticeable waste of power, and MOSFETS also tend to have lower heat dissipation, making them superior for high-power applications. For lower power applications, such as in this lab, there is little difference in performance between the two so a BJT may be a more likely choice due to its lower cost.
** Challenge 5-1
In this challenge the constants OnTime and OffTime in the code were altered to various values and the effects were observed. At low values such as 5ms the fan does not stop completely like when the on/off time was 5000ms but it appears to run at a slower speed than before. This is because power is still only being delivered to the fan for half the time (duty cycle) but the input is switched quickly between on and off so the fan runs steadily at a slower rate.
* Activity 2
In this activity, delivering power to devices using pulse width modulation was investigated. The first thing done in this activivity was to run the example program PwmTest.bs2
#+BEGIN_EXAMPLE
' -----[ Title ]-----------------------------------------------------------
' Process Control - PwmTest.bs2
' Uses Pulse Width Modulation to control fan speed
' {$STAMP BS2}
' {$PBASIC 2.5}
' -----[ Declarations ]----------------------------------------------------
Opto_SW PIN 8 ' Opto-Reflector
Fan PIN 2 ' Fan drive pin
Opto_Count VAR Word ' Count from opto-reflective switch
RPM VAR Word ' Calculated RPM
SP_Data VAR Word ' Data returned from StampPlot
CyclesPerRev CON 4 ' Encoder used
Duty VAR Byte ' Duty cycle value 0-255
Max_Count VAR Word ' Maximum count for calculating Per_RPM
Per_RPM VAR Word ' Percent of RPM 0-100
x VAR Byte ' General counting variable
' -----[ Initialization ]--------------------------------------------------
PAUSE 500 ' Connection stabilizing time
' -----[ Main Routine ]----------------------------------------------------
GOSUB Calibrate
DO
 FOR Duty = 100 TO 0 STEP 10 ' Drive PWM from 100% to 0%
 DEBUG "!TEXT (PTIME),98A,0.8A,(BLACK),",DEC Duty,CR ' Label plot
 GOSUB Apply_Drive
 COUNT Opto_SW,100,opto_count ' Measure counts for 100mSec
 Per_RPM = Opto_Count * 100 / Max_Count ' Calculate percent RPM
 DEBUG DEC Duty,",",DEC Per_RPM ,CR ' Plot data
 NEXT
LOOP
' -----[ Subroutines ]----------------------------------------------------
Apply_Drive: ' Apply drive with a 100msc period
 FOR x = 1 TO 15 ' Apply for 15 repetitions
 IF duty > 0 THEN HIGH Fan ' Check if any HIGH time
 DEBUG IBIN OUT2,CR ' Plot digital state of drive
 PAUSE Duty ' Apply for amount of high time 
IF duty < 100 THEN LOW Fan ' Check if any LOW time
 DEBUG IBIN OUT2,CR ' Plot digital state of drive
 PAUSE 100-Duty ' Apply for rest of 100mSec
 NEXT
RETURN
Calibrate: ' Finds max speed to calculate %RPM
 HIGH Fan ' Energize fan
 PAUSE 3000 ' Allow fan to come up to speed
 DO
 COUNT Opto_SW,100,Opto_Count ' Count Pulses
 RPM = Opto_Count * (60000 / 100) / CyclesPerRev ' Calculate RPM
 DEBUG CR,"!REQD 0,30,Maximum RPM=", DEC RPM, ' Request speed verification
 "\nEnter 1 if RPM OK.",
 "\nEnter 0 if not OK.",CR
 DEBUGIN DEC SP_Data ' Accept user's response
 Timeout:
 PAUSE 100
 LOOP UNTIL (SP_Data = 1) ' Repeat if user did not enter 1
 Max_Count = Opto_Count ' Save maximum count
 DEBUG "!RSET(CR)!RSET",CR ' Reset plot
RETURN 
#+END_EXAMPLE
This program cycles the fan through duty cycles of 100% to 0%. As the duty cycle is reduced, the signal spends more time LOW(off) than HIGH (on) and so the average voltage is reduced and less power is delivered to the fan. Plotting duty cycle against RPM with a representation of the digital signal to the fan produces the following graph:
#+ATTR_LATEX: :width 400px
file:image2.jpg
As can be seen on the graph, when the duty cycle reduces the spaces between the digital HIGH signal increases and RPM decreases likewise.\newline\newline
The main function used in the code for this activity is the PWM function. This function uses the syntax "PWM Pin, Duty, Cycles" where Pin is simply the pin which to output the signal to, Duty is the duty cycle from 0-255 where a value of 0 is 0% duty cycle and 255 is 100% duty cycle and Cycles is the total time of the PWM signal in milliseconds. For example if we wanted to send a PWM signal to our fan with a duty cycle of 30,50 or 70% we would use:
#+BEGIN_EXAMPLE
PWM Fan, 77, 100     '30% duty cycle
PWM Fan, 128, 100    '50% duty cycle
PWM Fan, 179, 100    '70% duty cycle
#+END_EXAMPLE
** Challenge 5-2
In this challenge, two aspects of the code from activity 2 were altered to observe the effects. First, the Apply-drive subroutine was altered to apply the pwm signal for 5 seconds instead of 1.5 seconds. This was done by changing the line:
#+BEGIN_EXAMPLE
 FOR x = 1 TO 15 ' Apply for 15 repetitions
#+END_EXAMPLE
to
#+BEGIN_EXAMPLE
 FOR x = 1 TO 50 ' Apply for 50 repetitions
#+END_EXAMPLE
This works because the PWM function is set to apply the signal for 100ms, so repeating this 50 times applies it for 5 seconds. This produced the following plot:
#+ATTR_LATEX: :width 300px
file:image3.jpg
By doing this, a more accurate measurement is expected for the rpm of the fan, since it gives the fan time to settle at a new speed. Before, when the PWM wasn't applied for sufficient time, the fan stil had inertia from the previous speed. There is an anomolous point in the plot, however, as the readings by the opto-reflective sensor are somewhat unstable and at the moment this reading was taken there happened to be a spike in the RPM reading. \newline\newline
Next, the main routine was edited as follows:
#+BEGIN_EXAMPLE
DO
 Duty = 75
 DEBUG "!TEXT (PTIME),98A,0.8A,(BLACK),",DEC Duty,CR
 GOSUB Apply_Drive
 PAUSE 2000 'Simulated code delay time
 COUNT Opto_SW,100,opto_count
 Per_RPM = Opto_Count * 100 / Max_Count
 DEBUG DEC Duty, ",", DEC Per_RPM ,CR
LOOP
#+END_EXAMPLE
The code now runs the fan with a duty cycle of 75/255 = 29% and introduces a delay of 2 seconds each loop. This produced the following plot:
#+ATTR_LATEX: :width 300px
file:image4.jpg
At the time the RPM measurement is taken, the result is usually an rpm reading of 0RPM and at other times unpredictable. This is because in the time of the 2 seconds delay, the fan slows down and reaches a low RPM value that the sensor has difficulty reading. In order to obtain a more accurate reading the delay should occur after measuring the rpms, so that the fan doesn't slow down before the measuremnt is taken.
* Activity 3
In this activity the concept of PWM filtering was investigated using the following circuit.
#+ATTR_LATEX: :width 200px
file:image5.jpg
Initially, R_L was not connected to the circuit and the following code was ran
#+BEGIN_EXAMPLE
' -----[ Title ]-----------------------------------------------------------
' Process Control - PwmFiltering.bs2
' Control of PWM filtering circuits through StampPlot
' {$STAMP BS2}
' {$PBASIC 2.5}
' -----[ Declarations ]----------------------------------------------------
ADC_DataIn VAR Byte ' Analog to Digital Converter data
PWM_Val VAR Byte ' Amount of PWM to apply as read from StampPlot
SampleAmount VAR Word ' Amount of time to apply as read from StampPlot
SampleCount VAR Word ' Count of applied PWM
Fan PIN 2 ' PWM Drive pin - For fan eventually
ADC_CS PIN 13 ' ADC Chip Select pin
ADC_Clk PIN 14 ' ADC Clock pin
ADC_Dout PIN 15 ' ADC Data output
' -----[ Initialize ] -----------------------------------------------------
PAUSE 1000 ' Connection stabilization
' -----[ Main Routine ]----------------------------------------------------
DO
 GOSUB Read_SP ' Read setting from StampPlot
 GOSUB DrivePWM ' Drive output
 FOR SampleCount = 1 TO SampleAmount ' Read ADC for number of samples
 GOSUB Read_ADC
 GOSUB PlotData ' Plot data
 NEXT
LOOP
' -----[ Subroutines ]-----------------------------------------------------
READ_SP:
 DEBUG "!READ (sldPWM)",CR ' Request PWM slider val. from StampPlot
 DEBUGIN DEC PWM_Val ' Accept value and store
 PAUSE 100
 DEBUG "!READ (sldSample)",CR ' Request number for sample from StampPlot
 DEBUGIN DEC SampleAmount ' Accept value and store
 PAUSE 100
RETURN
DrivePWM:
 DEBUG "^TEXT (PTIME),105A,0.8A,(BLACK),PWM\n",DEC PWM_Val,CR ' Label plot
 PWM Fan, PWM_Val, 255 ' Drive PWM
RETURN
Read_ADC: ' Read ADC 0831
 LOW ADC_CS ' Enable chip
 SHIFTIN ADC_Dout,ADC_Clk, MSBPOST,[ADC_DataIn\9] ' Clock in data from ADC
 HIGH ADC_CS ' Disable ADC
RETURN
PlotData: ' Send voltage data to StampPlot
 DEBUG DEC ADC_DataIn ,",",
 "[",DEC ADC_DataIn,",*,0.0196]",CR
 PAUSE 50
RETURN
#+END_EXAMPLE
Executing this code with no R_L produced the following plot in StampPlot by stepping up the PWM value in steps of 25 while keeping the number of samples at 50.
#+ATTR_LATEX: :width 300px
file:image6.jpg
The voltage is held at a relatively constant voltage, except at the higher PWM values. This is likely because two small capacitors were used in parallel to reach about 0.69\mu F, which leak some charge, and although the input impedance from the Stamp board is very high there is still some leakage current. The ripple as the capacitor discharges can be seen by holding the pwm value constant with a sample number of 255. 
#+ATTR_LATEX: :width 300px
file:image7.jpg
Next, an R_L of 1M\Omega was added to the circuit. Repeating the procedure from before, the following plot was produced.
#+ATTR_LATEX: :width 300px
file:image8.jpg
Now, the capacitor can be seen discharging rapidly. The rate at which it does this can be calculated by \(\tau = R \cdot C\). For 1M\Omega and 0.68\mu F this is about 0.748 seconds. The time it takes for the capacitor to fully discharge is about \(5\tau = 3.74 s\).
** Challenge 5-3
For this challenge, a predicted discharge time was calculated using a 100k\Omega resistor:
\[\tau = (1x10^5) \cdot (0.68x10^{-6}) = 0.068s\]
\[5\tau = 0.068 \cdot 5 = 0.34s\]
This time of less than a second was observed in StampPlot
#+ATTR_LATEX: :width 300px
file:image9.jpg
In the next part of this challenge R_1 was changed to 1M\Omega to slow down the charge time of the capacitor. By setting a very low sample # and removing R_L at about 20 seconds, the following graph was produced.
#+ATTR_LATEX: :width 300px
file:image10.jpg
At every sample point, when the pwm signal is applied, the capacitor charges a little more, even when the pwm value isn't changed. This is because the capacitor cannot fully charge in the 100ms set in the code. The time required for the capacitor to fully charge is the same as the time it would take to discharge, calculated earlier so baout 0.748 seconds. This cannot be achieved using one pulse of the PWM function, as the maximum value is 225ms, and we require about 750ms.
